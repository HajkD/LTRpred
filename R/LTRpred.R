#' @title Predict LTR retrotransposons in a given genome
#' @description Main pipeline to perform
#' sufficient LTR retrotransposon predictions for any genome of interest.
#' @param genome.file path to the genome file in \code{fasta} format.
#' @param index.file.harvest specify the name of the enhanced suffix array index file that is computed
#'  by \code{suffixerator} for the use of \code{LTRharvest}. This opten can be used in case the suffix file was previously 
#'  generated, e.g. during a previous call of this function. In this case the suffix array index
#'  file does not need to be re-computed for new analyses. This is particularly useful when 
#'  running \code{LTRpred} with different parameter settings.
#' @param index.file.digest specify the name of the enhanced suffix array index file that is computed
#'  by \code{suffixerator} for the use of \code{LTRdigest}. This opten can be used in case the suffix file was previously 
#'  generated, e.g. during a previous call of this function. In this case the suffix array index
#'  file does not need to be re-computed for new analyses. This is particularly useful when 
#'  running \code{LTRpred} with different parameter settings.
#' @param LTRdigest.gff path to the LTRdigest generated GFF file, in case LTRdigest files were pre-computed previously.
#' @param tabout.file path to the LTRdigest generated tabout file file, in case LTRdigest files were pre-computed previously.
#' @param orf.file path to the file generated by \code{\link{ORFpred}}, in case the orf prediction file was generated previously.
#' @param annotate annotation database that shall be queried to annotate predicted LTR transposons.
#' Default is \code{annotate = NULL} indicating that no annotation query is being performed.
#' Possible options are: \code{annotate = "Dfam"} (here the Dfam database must be stored locally and a nhammer search is performed against the Dfam database) or \code{annotate = "Repbase"} (here the Repbase database must be stored locally and a blastn search is performed against the Repbase database). Please consult the vignettes for details.
#' @param range define the genomic interval in which predicted LTR transposons shall be reported
#' . In case \code{range[1] = 1000} and \code{range[2] = 10000} then candidates are only 
#' reported if they start after position 1000 and end before position 10000 in their respective 
#' sequence coordinates. If \code{range[1] = 0} and \code{range[2] = 0}, 
#' so \code{range = c(0,0)} (default) then the entire genome is being scanned.
#' @param seed  the minimum length for the exact maximal repeats. Only repeats with the specified minimum length are considered in all subsequent analyses. Default is \code{seed = 30}.
#' @param minlenltr minimum LTR length. Default is \code{minlenltr = 100}. 
#' @param maxlenltr maximum LTR length. Default is \code{maxlenltr = 3500}.
#' @param mindistltr minimum distance of LTR starting positions. Default is \code{mindistltr = 4000}.
#' @param maxdistltr maximum distance of LTR starting positions. Default is \code{maxdistltr = 25000}.
#' @param similar minimum similarity value between the two LTRs in percent. \code{similar = 70}.
#' @param mintsd minimum target site duplications (TSDs) length. If no search for TSDs
#' shall be performed, then specify \code{mintsd = NULL}. Default is \code{mintsd = 4}.
#' @param maxtsd maximum target site duplications (TSDs) length. If no search for TSDs
#' shall be performed, then specify \code{maxtsd = NULL}. Default is \code{maxtsd = 20}.
#' @param vic number of nucleotide positions left and right (the vicinity) of the predicted
#'  boundary of a LTR that will be searched for TSDs and/or one motif (if specified). 
#'  Default is \code{vic = 60}.
#' @param overlaps specify how overlapping LTR retrotransposon predictions shall be treated. 
#' If \code{overlaps = "no"} is selected, then neither nested nor overlapping predictions will be reported in the output. In case \code{overlaps = "best"} is selected then in the case of two or more nested or overlapping predictions, solely the LTR retrotransposon prediction with
#' the highest similarity between its LTRs will be reported.
#' If \code{overlaps = "all"} is selected then all LTR retrotransposon predictions 
#' will be reported whether there are nested and/or overlapping predictions or not. 
#' Default is \code{overlaps = "best"}.
#' @param xdrop specify the xdrop value (> 0) for extending a seed repeat in both directions
#'  allowing for matches, mismatches, insertions, and deletions. The xdrop extension process
#'   stops as soon as the extension involving matches, mismatches, insersions, and deletions 
#'   has a score smaller than T -X, where T denotes the largest score seen so far. Default is \code{cdrop = 5}.
#' @param mat specify the positive match score for the X-drop extension process. Default is \code{mat = 2}.
#' @param mis specify the negative mismatch score for the X-drop extension process. Default is \code{mis = -2}.
#' @param ins specify the negative insertion score for the X-drop extension process. Default is \code{ins = -3}.
#' @param del specify the negative deletion score for the X-drop extension process. Default is \code{del = -3}.
#' @param motif specify 2 nucleotides for the starting motif and 2 nucleotides for the ending
#'  motif at the beginning and the ending of each LTR, respectively.
#'  Only palindromic motif sequences - where the motif sequence is equal to its complementary
#'  sequence read backwards - are allowed, e.g. \code{motif = "tgca"}. Type the nucleotides without any space
#'  separating them. If this option is not selected by the user, candidate pairs will not be
#'  screened for potential motifs. If this options is set but no allowed number of
#'  mismatches is specified by the argument \code{motifmis} and a search for the exact 
#'  motif will be conducted. If \code{motif = NULL} then no explicit motif is being specified.
#' @param motifmis allowed number of mismatches in the TSD motif specified in \code{motif}.
#' The number of mismatches needs to be between [0,3].  Default is \code{motifmis = 0}.
#' @param aaout shall the protein sequence of the HMM matches to the predicted LTR transposon 
#' be generated as fasta file or not. Options are \code{aaout = "yes"} or \code{aaout = "no"}.
#' @param aliout shall the alignment of the protein sequence of the HMM matches to the predicted LTR transposon 
#' be generated as fasta file or not. Options are \code{aaout = "yes"} or \code{aaout = "no"}.
#' @param pptlen a two dimensional numeric vector specifying the minimum and maximum allowed
#' lengths for PPT predictions. If a purine-rich region that does not fulfill this range is
#' found, it will be discarded. Default is \code{pptlen = c(8,30)} (minimum = 8; maximum = 30).
#' @param uboxlen a two dimensional numeric vector specifying the minimum and maximum allowed
#' lengths for U-box predictions. If a T-rich region preceding a PPT that does not fulfill the PPT length criteria is
#' found, it will be discarded. Default is \code{uboxlen = c(3,30)} (minimum = 3; maximum = 30).
#' @param pptradius a numeric value specifying the area around the 3' LTR beginning to be 
#' considered when searching for PPT. Default value is \code{pptradius = 30}.
#' @param trnas path to the fasta file storing the unique tRNA sequences that shall be matched to the
#' predicted LTR transposon (tRNA library). 
#' @param pbsalilen a two dimensional numeric vector specifying the minimum and maximum allowed
#' lengths for PBS/tRNA alignments. If the local alignments are shorter or longer than this
#' range, it will be discarded. Default is \code{pbsalilen = c(11,30)} (minimum = 11; maximum = 30).
#' @param pbsoffset a two dimensional numeric vector specifying the minimum and maximum allowed
#' distance between the start of the PBS and the 3' end of the 5' LTR. Local alignments not 
#' fulfilling this criteria will be discarded. Default is \code{pbsoffset = c(0,5)} (minimum = 0; maximum = 5).
#' @param pbstrnaoffset a two dimensional numeric vector specifying the minimum and maximum allowed
#' PBS/tRNA alignment offset from the 3' end of the tRNA. Local alignments not 
#' fulfilling this criteria will be discarded. Default is \code{pbstrnaoffset = c(0,5)} (minimum = 0; maximum = 5).
#' @param pbsmaxedist a numeric value specifying the maximal allowed unit edit distance in a
#' local PBS/tRNA alignment.
#' @param pbsradius a numeric value specifying the area around the 5' LTR end to be 
#' considered when searching for PBS Default value is \code{pbsradius = 30}.
#' @param hmms a character string or a character vector storing either the hmm files for
#' searching internal domains between the LTRs of predicted LTR transposons or a vector of
#' Pfam IDs from http://pfam.xfam.org/ that are downloaded and used to search for corresponding protein domains
#' within the predicted LTR transposons. As an option users can rename all of their hmm files
#' so that they start for example with the name \code{hmms = "hmm_*"}. This way all files starting with 
#' \code{hmm_} will be considered for the subsequent protein domain search. In case Pfam IDs 
#' are specified, the \code{LTRpred} function will automatically download the corresponding 
#' HMM files and use them for further protein domain searches. In case users prefer to specify 
#' Pfam IDs please specify them in the \code{pfam.ids} parmeter and choose \code{hmms = NULL}.  
#' @param pdomevalcutoff a numeric value specifying the E-value cutoff for corresponding HMMER searches. All hits that do not fulfill this criteria are discarded. Default is \code{pdomevalcutoff = 1E-5}.
#' @param pbsmatchscore specify the match score used in the PBS/tRNA Smith-Waterman alignment.
#' Default is \code{pbsmatchscore = 5}.
#' @param pbsmismatchscore specify the mismatch score used in the PBS/tRNA Smith-Waterman alignment.
#' Default is \code{pbsmismatchscore = -10}.
#' @param pbsinsertionscore specify the insertion score used in the PBS/tRNA Smith-Waterman alignment.
#' Default is \code{pbsinsertionscore = -20}.
#' @param pbsdeletionscore specify the deletion score used in the PBS/tRNA Smith-Waterman alignment.
#' Default is \code{pbsdeletionscore = -20}.
#' @param pfam.ids a character vector storing the Pfam IDs from http://pfam.xfam.org/
#' that shall be downloaded and used to perform protein domain searches within the sequences
#' between the predicted LTRs.
#' @param cores number of cores to be used for multicore processing.
#' @param orf.style type of predicting open reading frames (see documentation of USEARCH).
#' @param min.codons minimum number of codons in the predicted open reading frame.
#' @param trans.seqs logical value indicating wheter or not predicted open reading frames
#' shall be translated and the corresponding protein sequences stored in the output folder.
#' @param output.path a path/folder to store all results returned by \code{\link{LTRharvest}}, \code{\link{LTRdigest}}, and \code{LTRpred}. 
#' If \code{output.path = NULL} (Default) then a folder with the name of the input genome file
#' will be generated in the current working directory of R and all results are then stored in this folder.
#' @param verbose shall further information be printed on the console or not. 
#' @author Hajk-Georg Drost
#' @details This function provides the main pipeline to perform \code{de novo} LTR transposon
#' predictions.
#' 
#' @seealso \code{\link{LTRharvest}}, \code{\link{LTRdigest}}, \code{\link{PlotLTRAge}}, \code{\link{PlotLTRWidth}}, \code{\link{PlotLTRRange}},
#' \code{\link{read.prediction}}, \code{\link{read.tabout}}, \code{\link{read.seqs}},
#' \code{\link{pred2fasta}}, \code{\link{pred2gff}}
#' @importFrom magrittr %>%
#' @return 
#' The \code{LTRpred} function generates the following output files:
#' 
#' \itemize{
#' \item *_BetweenLTRSeqs.fsa : DNA sequences of the region between the LTRs in fasta format. 
#' \item *_Details.tsv : A spread sheet containing detailed information about the predicted LTRs.
#' \item *_FullLTRRetrotransposonSeqs.fsa : DNA sequences of the entire predicted LTR retrotransposon.
#' \item *_index.fsa : The suffixarray index file used to predict putative LTR retrotransposons.
#' \item *_Prediction.gff : A spread sheet containing detailed additional information about the predicted LTRs (partially redundant with the *_Details.tsv file).
#' \item *_index_ltrdigest.fsa : The suffixarray index file used to predict putative LTR retrotransposonswith \code{LTRdigest}.
#' \item *_LTRdigestPrediction.gff : A spread sheet containing detailed information about the predicted LTRs.
#' \item *-ltrdigest_tabout.csv : A spread sheet containing additional detailed information about the predicted LTRs.
#' \item *-ltrdigest_complete.fas : The full length DNA sequences of all predicted LTR transposons.
#' \item *-ltrdigest_conditions.csv : Contains information about the parameters used for a given
#' \code{LTRdigest} run.
#' \item *-ltrdigest_pbs.fas : Stores the predicted PBS sequences for the putative LTR retrotransposons.
#' \item *-ltrdigest_ppt.fas : Stores the predicted PPT sequences for the putative LTR retrotransposons.
#' \item *-ltrdigest_5ltr.fas and *-ltrdigest_3ltr.fas: Stores the predicted 5' and 3' LTR sequences. Note: If the direction of the putative retrotransposon could be predicted, these
#' files will contain the corresponding 3' and 5' LTR sequences. If no direction could be
#' predicted, forward direction with regard to the original sequence will be assumed by 
#' \code{LTRdigest}, i.e. the 'left' LTR will be considered the 5' LTR.
#' \item *-ltrdigest_pdom_<domainname>.fas : Stores the DNA sequences of the HMM matches
#' to the LTR retrotransposon candidates. 
#' \item *-ltrdigest_pdom_<domainname>_aa.fas : Stores the concatenated protein sequences of 
#' the HMM matches to the LTR retrotransposon candidates.
#' \item *-ltrdigest_pdom_<domainname>_ali.fas : Stores the alignment information for all matches of the given protein domain model to the translations of all candidates.
#' \item *_orfs_nt.fsa : Stores the predicted open reading frames within the predicted LTR transposons as DNA sequence.
#' \item *_orfs_aa.fsa : Stores the predicted open reading frames within the predicted LTR transposons as protein sequence.
#' \item *_LTRpred.gff : Stores the \code{LTRpred} predicted LTR transposons in GFF format.
#' \item *_LTRpred.bed : Stores the \code{LTRpred} predicted LTR transposons in BED format. 
#' \item *_LTRpred-DataSheet.csv : Stores the output table as data sheet.
#' }
#' The ' * ' is an place holder for the name of the input genome file.
#' @examples 
#' \dontrun{
#' # generate de novo LTR transposon prediction
#' pred <- LTRpred(genome.file = "TAIR10_chr_all.fas",
#'                 trnas       = "plantRNA_Arabidopsis.fsa",
#'                 hmms        = "hmm_*")
#' 
#' # run LTRpred with pre-computed predictions from LTRdigest()  
#' genome <- system.file("TAIR10_chr_all_LTRdigestPrediction.gff",package = "LTRpred")   
#' tabout <- system.file("TAIR10_chr_all-ltrdigest_tabout.csv",package = "LTRpred")
#' orf.pred <- system.file("nt.fa",package = "LTRpred")              
#' pred <- LTRpred(LTRdigest.gff = genome,
#'                 tabout.file   = tabout,
#'                 orf.file      = orf.pred)
#'}
#' @references 
#' R Edgar. Search and clustering orders of magnitude faster than BLAST. Bioinformatics (2010) 26 (19): 2460-2461.
#' 
#' D Ellinghaus, S Kurtz and U Willhoeft. LTRharvest, an efficient and flexible software for de novo detection of LTR retrotransposons. BMC Bioinformatics (2008). 9:18.
#' 
#' S Steinbiss et al. Fine-grained annotation and classification of de novo predicted LTR retrotransposons. Nucl. Acids Res. (2009) 37 (21): 7002-7013.
#' @export
LTRpred <- function(genome.file       = NULL,
                    index.file.harvest = NULL,
                    index.file.digest = NULL,
                    LTRdigest.gff     = NULL,
                    tabout.file       = NULL,
                    orf.file          = NULL,
                    annotate          = NULL,
                    range             = c(0,0),
                    seed              = 30,
                    minlenltr         = 100,
                    maxlenltr         = 3500,
                    mindistltr        = 4000,
                    maxdistltr        = 25000,
                    similar           = 70,
                    mintsd            = 4,
                    maxtsd            = 20,
                    vic               = 60,
                    overlaps          = "no",
                    xdrop             = 5,
                    mat               = 2,
                    mis               = -2,
                    ins               = -3,
                    del               = -3,
                    motif             = NULL,
                    motifmis          = 0,
                    aaout             = "yes",
                    aliout            = "yes",
                    pptlen            = c(8,30),
                    uboxlen           = c(3,30),
                    pptradius         = 30,
                    trnas             = NULL,
                    pbsalilen         = c(11,30),
                    pbsoffset         = c(0,5),
                    pbstrnaoffset     = c(0,5),
                    pbsmaxedist       = 1,
                    pbsradius         = 30,
                    hmms              = NULL,
                    pdomevalcutoff    = 1E-5,
                    pbsmatchscore     = 5,
                    pbsmismatchscore  = -10,
                    pbsinsertionscore = -20,
                    pbsdeletionscore  = -20,
                    pfam.ids          = NULL,
                    cores             = 1,
                    orf.style         = 7,
                    min.codons        = 200,
                    trans.seqs        = FALSE,
                    output.path       = NULL,
                    verbose           = TRUE){
  
  if (!is.null(annotate)){
    if (!is.element(annotate,c("Repbase","Dfam")))
      stop ("Only Dfam or Repbase can be used to annotate predicted LTR transposons!")
  }
  
  if (parallel::detectCores() < cores)
    stop ("Your system does not provide the number of cores you specified.")
  
  if (is.null(output.path)){
    if (!is.null(genome.file)){
      output.path <- paste0(unlist(stringr::str_split(basename(genome.file),"[.]"))[1],"_ltrpred")
    } else {
      output.path <- paste0(unlist(stringr::str_split(basename(LTRdigest.gff),"[.]"))[1],"_ltrpred")
    }
    
    if (dir.exists(output.path)){
      unlink(output.path, recursive = TRUE)
      dir.create(output.path)
    } else {
      dir.create(output.path)
    }
  } else {
    
    if (dir.exists(output.path)){
      unlink(output.path, recursive = TRUE)
      dir.create(output.path)
    } else {
      dir.create(output.path)
    }
  }
  
  rTSD_end <- lTSD_start <- PPT_end <- PPT_start <- PBS_end <- PBS_start <- NULL
  ID <- match_width <- reading_frame <- width <- NULL
  
  if (!is.null(genome.file) & is.null(LTRdigest.gff) & is.null(tabout.file)){
  
           LTRharvest(genome.file,
                      index.file  = index.file.harvest,
                      range       = range,
                      seed        = seed,
                      minlenltr   = minlenltr,
                      maxlenltr   = maxlenltr,
                      mindistltr  = mindistltr,
                      maxdistltr  = maxdistltr,
                      similar     = similar,
                      mintsd      = mintsd,
                      maxtsd      = maxtsd,
                      vic         = vic,
                      overlaps    = overlaps,
                      xdrop       = xdrop,
                      mat         = mat,
                      mis         = mis,
                      ins         = ins,
                      del         = del,
                      motif       = motif,
                      motifmis    = motifmis,
                      output.path = NULL,
                      verbose     = verbose) 
  
  chopped.foldername <- unlist(stringr::str_split(basename(genome.file),"[.]"))[1]
  LTRdigest(input.gff3        = file.path(paste0(chopped.foldername,"_ltrharvest"),paste0(chopped.foldername,"_Prediction.gff")),
            genome.file       = genome.file,
            aaout             = aaout,
            aliout            = aliout,
            pptlen            = pptlen,
            uboxlen           = uboxlen,
            pptradius         = pptradius,
            trnas             = trnas,
            pbsalilen         = pbsalilen,
            pbsoffset         = pbsoffset,
            pbstrnaoffset     = pbstrnaoffset,
            pbsmaxedist       = pbsmaxedist,
            pbsradius         = pbsradius,
            hmms              = hmms,
            pdomevalcutoff    = pdomevalcutoff,
            pbsmatchscore     = pbsmatchscore,
            pbsmismatchscore  = pbsmismatchscore,
            pbsinsertionscore = pbsinsertionscore,
            pbsdeletionscore  = pbsdeletionscore,
            pfam.ids          = pfam.ids,
            cores             = cores,
            index.file        = index.file.digest,
            output.path       = NULL) 
  
  
  LTRdigestOutput <- read.prediction(gff.file    = file.path(paste0(chopped.foldername,"_ltrdigest"),paste0(chopped.foldername,"_LTRdigestPrediction.gff")),
                                     tabout.file = file.path(paste0(chopped.foldername,"_ltrdigest"),paste0(chopped.foldername,"-ltrdigest_tabout.csv")),
                                     program     = "LTRdigest")
  } else {
    
    LTRdigestOutput <- read.prediction(gff.file    = LTRdigest.gff,
                                       tabout.file = tabout.file,
                                       program     = "LTRdigest")
  }
  
  if (is.null(orf.file)){
    ORFTable <- ORFpred(seq.file = file.path(paste0(chopped.foldername,"_ltrdigest"),paste0(chopped.foldername,"-ltrdigest_complete.fas")), 
                        orf.style  = orf.style, 
                        min.codons = min.codons, 
                        trans.seqs = trans.seqs,
                        output     = output.path)
  } else {
    
    ORFTable <- read.orfs(input.file = orf.file)
  }
  
  names(ORFTable)[3:4] <- c("element_start","element_end") 
  
  LTRdigestOutput$ltr.retrotransposon <- dplyr::full_join(LTRdigestOutput$ltr.retrotransposon, ORFTable, by = c("chromosome" = "chromosome", "start" = "element_start", "end" = "element_end"))
 
  LTRdigestOutput$ltr.retrotransposon <- dplyr::mutate(LTRdigestOutput$ltr.retrotransposon, repeat_region_length = ifelse(!is.na(rTSD_end), (rTSD_end - lTSD_start) + 1, NA))
  
  LTRdigestOutput$ltr.retrotransposon <- dplyr::mutate(LTRdigestOutput$ltr.retrotransposon, PPT_length = ifelse(!is.na(PPT_end),(PPT_end - PPT_start) + 1, NA))
  
  LTRdigestOutput$ltr.retrotransposon <- dplyr::mutate(LTRdigestOutput$ltr.retrotransposon, PBS_length = ifelse(!is.na(PBS_end), (PBS_end - PBS_start) + 1, NA))
  
  ProteinMatch <- dplyr::select(LTRdigestOutput$protein.match,ID, start, end, match_width, reading_frame)
  colnames(ProteinMatch) <- c("ID","protein_domain_start","protein_domain_end","protein_domain_match_width","protein_domain_reading_frame")
  
  LTRdigestOutput$ltr.retrotransposon <- dplyr::inner_join(LTRdigestOutput$ltr.retrotransposon, ProteinMatch, by = "ID")
  
  RR_tract <- dplyr::select(LTRdigestOutput$RR_tract,ID, start, end, width)
  colnames(ProteinMatch) <- c("ID","RR_tract_start","RR_tract_end","RR_tract_length")
  
  LTRdigestOutput$ltr.retrotransposon <- dplyr::inner_join(LTRdigestOutput$ltr.retrotransposon, RR_tract, by = "ID")
  
  element_start <- element_length <- `width.y` <- `start.y`<- `end.y` <- NULL
  
  res <- dplyr::select(LTRdigestOutput$ltr.retrotransposon, -c(element_start,element_length,`width.y`, `start.y`, `end.y`))
  names(res)[c(4,5,9)] <- c("start","end","width")
  
  if (!is.null(genome.file)){
    
    file.copy(paste0(chopped.foldername,"_ltrharvest"),output.path, recursive = TRUE)
    file.copy(paste0(chopped.foldername,"_ltrdigest"),output.path, recursive = TRUE)
    file.remove(paste0(chopped.foldername,"_ltrharvest"), recursive = TRUE)
    file.remove(paste0(chopped.foldername,"_ltrdigest"), recursive = TRUE)
    write.table(pred2gff(res),file.path(output.path,paste0(chopped.foldername,"_LTRpred.gff")), 
                quote     = FALSE, 
                col.names = FALSE, 
                row.names = FALSE)
    
    write.table(pred2bed(res),file.path(output.path,paste0(chopped.foldername,"_LTRpred.bed")), 
                quote     = FALSE, 
                col.names = FALSE, 
                row.names = FALSE)
    write.table(res,file.path(output.path,paste0(chopped.foldername,"_LTRpred-DataSheet.csv")), 
                quote     = FALSE, 
                col.names = TRUE, 
                row.names = FALSE)
  } else {
    file.copy(LTRdigest.gff,output.path, recursive = TRUE)
    file.copy(tabout.file,output.path, recursive = TRUE)
    file.remove(LTRdigest.gff, recursive = TRUE)
    file.remove(tabout.file, recursive = TRUE)
    write.table(pred2gff(res),file.path(output.path,paste0(basename(LTRdigest.gff),"_LTRpred.gff")), 
                quote     = FALSE, 
                col.names = FALSE, 
                row.names = FALSE)
    
    write.table(pred2bed(res),file.path(output.path,paste0(basename(LTRdigest.gff),"_LTRpred.bed")), 
                quote     = FALSE, 
                col.names = FALSE, 
                row.names = FALSE)
    
    write.table(res,file.path(output.path,paste0(basename(LTRdigest.gff),"_LTRpred-DataSheet.csv")), 
                quote     = FALSE, 
                col.names = TRUE, 
                row.names = FALSE)
  }

  return(res)
  
  # here implement nhmmer search to Dfam
  # dfam.query()
}





